# Thought
用bfs找到最短的path
- [ ] bfs
用set看重复：

  1. 不是ideal == visited就是全部reachable，考虑第3页可以跳到第3页，但是没有其他页可以跳到第3页的情况

# Code (dfs) out of time limit
```python
# 2018 J5
pages = int(input())
books = []
visited = set([1])
ideal = set([i for i in range(1,pages+1)])
for i in range(pages):
    inp = list(map(int,input().split()))
    books.append(inp)
    page_curr = len(books)
    for each in inp[1:]:
        if each == page_curr:# important
            continue
        visited.add(each)
if visited == ideal:
    print('Y')
else:
    print('N')
    
shortest = 10000
def dfs(curr, path): 
    global shortest
    if books[curr][0] ==0:
        shortest = min(shortest, len(path)+1)
        #print(path, curr)
        return
    if curr in path:
        return
    for each in range(1,books[curr][0]+1):
        dfs(books[curr][each]-1, path+[curr])
dfs(0,[])

print(shortest)

```
